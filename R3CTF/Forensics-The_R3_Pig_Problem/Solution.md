## Initial explorarion

### Step 1: Examining the TCP stream

I opened the 'pig.pcapng' file in Wireshark and followed the TCP stream . This stream repeatedly transmitted blocks of digits resembling the mathematical constant π (pi), such as:

314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912EOF

This block of digits was **repeated three times**, each appearing identical at first glance. I considered the possibility that subtle differences in the digits might encode hidden data , so I carefully compared the blocks for inconsistencies or strategic deviations — **none were found**.

At this point, it became clear that the π digits were most likely a **decoy**.

## Actual Plan

### Step 2: Investigating Packet Timing 

Given the lack of useful payload data, I hypothesized that the flag might be encoded in **inter-packet timing**, a common covert channel technique.

We filtered packets by source port 1337 and extracted their timestamps using `tshark`:

```bash
tshark -r pig.pcapng -Y "tcp.srcport == 1337" -T fields -e frame.time_epoch > times.txt 
```


### Step 3: Calculating Inter-Packet Delays

To analyze timing as a potential signal, I computed the difference (delta) between each consecutive timestamp:

```bash
awk 'NR==1{prev=$1; next} {delta = $1 - prev; printf "%.6f\n", delta; prev = $1}' times.txt > deltas.txt
```

Now, each line in deltas.txt showed the delay (in seconds) between two packets.

### Step 4: Converting Delays to Binary

Assuming a binary encoding based on delay thresholds (short = 0, long = 1), I chose a threshold of 0.1 seconds and translated the delays into a binary string:

```bash
awk '{if ($1 > 0.1) printf "1"; else printf "0"} END {print ""}' deltas.txt > bits.txt
```

This leaves us with a long binary string, potentially representing ASCII-encoded data.

### Step 5: Brute-Forcing Bit Alignment

Initial decoding of the binary data produced junk characters, likely due to misalignment with byte boundaries.

To solve this, I brute-forced all bit-shift alignments (from shift 1 to 7) and re-attempted decoding at each step:

<pre><code>def binary_to_ascii(bin_str):
    chars = []
    for i in range(0, len(bin_str), 8):
        byte = bin_str[i:i+8]
        if len(byte) < 8:
            continue  # Ignore incomplete byte
        chars.append(chr(int(byte, 2)))
    return ''.join(chars)

def try_bit_shifts(binary_str):
    results = []
    length = len(binary_str)
    for shift in range(1, 8):  # only shifting within 1 byte (0-7)
        left_shifted = binary_str[shift:]
        right_shifted = binary_str[:-shift]

        left_ascii = binary_to_ascii(left_shifted)
        right_ascii = binary_to_ascii(right_shifted)

        results.append((f"Left shift {shift} bit(s)", left_ascii))
        results.append((f"Right shift {shift} bit(s)", right_ascii))
    return results

binary_data = "001001101011110010010000001100011011100100110000101111010011110010010000001100001011100100110110101111001001000000110101101101110011011110111011101110011001000000111010001101000011001010010000001110000011010010110011101110011001001110010000001110011011001010110001101110010011001010111010000100001001000000111001000110011011000110111010001100110011110110111010001101000001100110010110101110100011010000111001000110011001100110010110101100010001100000110010001111001001011010111000001110010001100000110001001101100011001010110110100101101011010000011010001100100001011010110111000110000001011010111001101101111011011000111010101110100011010010110111101101110011111010010000001000100011011110010000001101110011011110111010000100000011000010110111001110011011101110110010101110010001000010010000001000100011011110010000001101110011011110111010000100000011000010110111001110011011101110110010101110010001000010010000100100000010001000110111100100000011011100110111101110100001000000110000101101110011100110111011101100101011100100010000100100001001000010100110101111001001000000110001101110010011000010111101001111001001000000110000101110010011011010111100100100000011010110110111001101111011101110111001100100000011101000110100001100101001000000111000001101001011001110111001100100111001000000111001101100101011000110111001001100101011101000010000100100000011100100011001101100011011101000110011001111011011101000110100000110011001011010111010001101000011100100011001100110011001011010110001000110000011001000100"

for label, text in try_bit_shifts(binary_data):
    print(f"{label}:\n{text}\n{'-'*40}")
</code></pre>

After trying all shifts, one of them revealed a readable flag in ASCII.



